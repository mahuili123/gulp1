#javascript垃圾收集器
自动垃圾回收机制管理内存
##优点
简化开发，节省代码
#缺点
无法完整掌握内存
#Node的内存管理
服务器端的node有必要管理内存
内存泄露后果严重，有可能引起文件描述符耗尽和连接占满
#V8内存限制
64位 1.4G 32位 0.7G
无法操作大对象
node.js中的js对象都是通过v8进行分配管理内存的。
##为何限制内存量
V8的垃圾收集原理
1.5G内存 完全收集一次 需要1秒以上
这一秒种是叫stop the world,应用的性能和响应能力都会下降
##如何打开内存限制
node --max-old-space-size=2000 app.js 单位是M
node --max-new-space-size=1024 app.js 单位是kb
一旦初始化成功，生效不能再修改
#V8的垃圾回收机制
V8是基于分代的垃圾回收。分为新生代和老生代
按存活的时间来划分的。
##内存分代
- 年龄小的新生代，
  默认情况下 64位 新生代内存是32M 
           32位 新生代内存是16M 
  新生代由两块from to 区域组成。每块是 64 16M    32位  8M     
- 年龄大的老生代  
 默认情况下 64位 老生代内存是1400M
          32位 老生代内存是700M
##新生代垃圾回收算法
- 大多数对象被分配在这里，这是它们出生的地方
- 这个区域很小，但垃圾回收非常频繁
- 当指针到达末尾时，要进行垃圾回收
- 新生代通过scavenge算法进行回收
- scavenge
 新生代匹配一分为二，每个16M
 一个使用，一个空闲
 开始垃圾回收时，会检查from里的存活对象，如果还活着，拷贝到to空间里去。
 非存放对象，释放空间
 完成复制后，from 和to 角色互换
 复制的过程采用广度优先的策略,从根对象出现，遍历所有能直接访问的对象
 优点 是速度快，效率高
 缺点是浪费空间
 但是由于存活对象少，空间小，所以这种方案最合适
 
 当一个对象经历过多闪的复制依然存活时，它就是生存周期比较长的对象的
 会被移动到老生代，这个移动过程称为晋升或升级
 有两种情况会晋升
 1. 经过5次以上回收。
 2. to的空间内存使用占比超过25%,或超大对象
##老生代垃圾回收算法 
mark-sweep mark-compact
标记-清除    标记-整理
##mark-sweep
标记活着的对象，随后清除在标记阶段没有标记的对象，只清理死亡对象
活着的对象在新生代比较多，在老生代比较少
问题在于清除后会出现内存不连续的情况。这种内存碎片会对后续的分配造成影响 
如果要分配一个大对象，碎片空间无法分配
##mark-compact
标记死亡后进行整理，活着的对象往左端移动，移动 完成后，直接清理掉
边界外的内存。
##incremental making 增量标记
以上三种回收时都需要暂停程序运行，收集完成后才进行恢复。stop the world
在新生代影响不大。
在老生代内存空间大，存活对象多，耗时比较长，比较严重
把标记改为了增量标记。将一口气的停顿拆分成了多个小步骤。
做完一步程序运行一会儿，垃圾回收和应用程序运行交替进行。
停顿时间可以减少到1/6左右

#查看垃圾回收日志
##trace_gc
node --trace_gc --trace_gc_verbose 2.traceGc.js > trace.log
知道何时执行GC，每次GC的时间以及每个区域的内存占用情况
##prof
可以得到V8执行性能分析，包括垃圾回收的占用时间
https://github.com/ngryman/v8-windows-tickprocessor

#如何高效使用内存
我们要让垃圾回收器更高效的工作
##如何释放内存
scope closure

#内存指标
堆内存傅得总是小于RSS，NODE中的内存并不全都是由V8进行分配的
不通过V8分配 的内存称为堆 外内存
#内存泄漏
NODE对内存泄露非常敏感。
内存泄露只有一种原因 就是对象没有回收 变成了老生代的常驻对象
##缓存使用不合理
##队列消费不及时
 警告，发邮件或短信警告
 拒绝或者抛弃
##闭包，作用域未释放

##内存泄露的排查
##heapdump
https://github.com/bnoordhuis/node-heapdump
linux centos
yum install httpd-tools

#memwatch
安装
npm install memwatch-next
http://jingyan.baidu.com/article/29697b912f6539ab20de3cf8.html

# node如何处理大对象
pipe



